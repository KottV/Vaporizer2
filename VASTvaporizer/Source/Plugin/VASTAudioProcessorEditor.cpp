/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "../Engine/VASTEngineHeader.h"
#include "VASTAudioProcessor.h"
#include "VASTAudioProcessorEditor.h"
#include "VASTVaporizerComponent.h"

//==============================================================================
VASTAudioProcessorEditor::VASTAudioProcessorEditor(VASTAudioProcessor& p)
: AudioProcessorEditor(p), processor(&p) {
    
    if (juce::Desktop::getInstance().isHeadless() == false)
    {
        juce::Rectangle<int> r = Desktop::getInstance().getDisplays().getPrimaryDisplay()->userArea;
        int screenW = r.getWidth();
        int screenH = r.getHeight();
        if (m_iMaxWidth > screenW) m_iMaxWidth = screenW;
        if (m_iMaxHeight > screenH) m_iMaxHeight = screenH;
    }
    
	processor->m_mapParameterNameToControl.clear(); //clear slider mapping
    resizeCalledFromConstructor = true;
    vaporizerComponent.reset(new VASTVaporizerComponent(this, processor));
	vaporizerComponent->setVisible(false);
    
	m_VASTComponentsAll = juce::Array<Component*>();
	//Make sure that before the constructor has finished, you've set the
	//editor's size to whatever you need it to be.

#if defined JUCE_LINUX
	setResizable(false, false);
#else
	setResizable(true, true);
#endif

	if ((processor->m_iUserTargetPluginHeight == 0) || (processor->m_iUserTargetPluginWidth == 0)) {
		processor->m_iUserTargetPluginWidth = processor->m_iDefaultPluginWidth;
		processor->m_iUserTargetPluginHeight = processor->m_iDefaultPluginHeight;
	}

	tooltipWindow.setLookAndFeel(getProcessor()->getCurrentVASTLookAndFeel());

	resizeCalledFromConstructor = true;
#if !defined JUCE_LINUX
	m_componentBoundsConstrainer.setFixedAspectRatio(processor->m_dPluginRatio);
	m_componentBoundsConstrainer.setSizeLimits(m_iMinWidth, m_iMinHeight, m_iMaxWidth, m_iMaxHeight); //CHECK https://forum.juce.com/t/best-way-to-implement-resizable-plugin/12644/5
	setConstrainer(&m_componentBoundsConstrainer);
#endif

	setOpaque(true);
    //setSize(1,1); //intermediate
	setSize(processor->m_iUserTargetPluginHeight * processor->m_dPluginRatio, processor->m_iUserTargetPluginHeight);

    startTimer(0, 100); //ui update
    startTimer(1, 10); //param update

}

VASTAudioProcessorEditor::~VASTAudioProcessorEditor() {
	processor->resetCurrentEditorInitialized();
	this->removeAllChildren();
	m_alertWindow = nullptr;
	stopTimer(0);
	stopTimer(1); //param update	
	this->setLookAndFeel(nullptr);
	vaporizerComponent = nullptr;
}

Component* VASTAudioProcessorEditor::findChildComponetWithName(Component* parent, String compName)
{
	Component* retComp = nullptr;
	for (int i = 0; i < parent->getNumChildComponents(); ++i)
	{
		Component* childComp = parent->getChildComponent(i);
		if (childComp->getName().equalsIgnoreCase(compName))
			return childComp;
		if (childComp->getNumChildComponents()) {
			if (retComp == nullptr)
				retComp = findChildComponetWithName(childComp, compName);
			else
				return retComp;
		}
	}
	return retComp;
}

//should be optimal now
void VASTAudioProcessorEditor::timerCallback(int timerID) {
    if (mi_update_delay<10) {
        mi_update_delay++;
        return;
    }
    
	if (!processor->isCurrentEditorInitialized()) {
		if (vaporizerComponent.get() != nullptr) {
			addChildComponent(vaporizerComponent.get());
			vaporizerComponent->setVersionText(processor->getVersionString());
			resizeCalledFromConstructor = false;
			resized();
			vaporizerComponent->setVisible(true);
			processor->setCurrentEditorInitialized();
		}
		else
			return;
	}
    
    if (vaporizerComponent->isActive == false)
        return; //not yet ready?
    
    if (!isVisible()) {
        processor->m_editorIsProbablyVisible.store(false);
        return;
    }
    else
        processor->m_editorIsProbablyVisible.store(true);
	if (timerID == 1) { //component update
		if (processor->m_bShallComponentValueUpdate.load()) {
			if (processor->m_shallComponentUpdate != "") {
				VASTSlider* lslider = dynamic_cast<VASTSlider*>(findChildComponetWithName(vaporizerComponent.get(), processor->m_shallComponentUpdate));
				if (lslider != nullptr) {
					if (lslider->getComponentID().equalsIgnoreCase(processor->m_shallComponentUpdate)) {
						float sVal = lslider->getRange().getStart() + (lslider->getRange().getEnd() - lslider->getRange().getStart()) * jlimit<float>(0.f, 1.f, processor->m_shallComponentUpdateValue);
						lslider->setValue(sVal, NotificationType::sendNotificationAsync);
					}
				}
			}
			processor->m_bShallComponentValueUpdate.store(false);
		}
	}
	else { //ui update
		vaporizerComponent->setLicenseText(processor->getLicenseText(), processor->isInErrorState(), processor->getErrorState());

		if (processor->m_showNewerVersionPopup) {
			showNewerVersionPopup();
		}

		if (processor->needsUIInit()) {
			vaporizerComponent->initAll();
			processor->clearUIInitFlag();
		}

		if (processor->needsUIUpdate()) {
			if (processor->needsUIUpdate_tabs())
				vaporizerComponent->updateAll();

			if (processor->needsUIUpdate_matrix())
				vaporizerComponent->updateMatrixDisplay();

			if (processor->needsUIUpdate_sliders()) {
				if ((processor->needsUIUpdate_slider1dest() == -1) && (processor->needsUIUpdate_slider2dest() == -1)) { //repaint all sliders 
					for (int i = 0; i < processor->m_mapParameterNameToControl.size(); i++) {
						VASTParameterSlider* lslider = dynamic_cast<VASTParameterSlider*>(processor->m_mapParameterNameToControl[i]);
						if (lslider != nullptr) {
							if (lslider->isShowing())
								lslider->repaint();
						}
					}
				}
				else { //repaint only the two that are given
					String param1name = processor->autoDestinationGetParam(processor->needsUIUpdate_slider1dest());
					String param2name = processor->autoDestinationGetParam(processor->needsUIUpdate_slider2dest());

					for (int i = 0; i < processor->m_mapParameterNameToControl.size(); i++) {
						VASTParameterSlider* lslider = dynamic_cast<VASTParameterSlider*>(processor->m_mapParameterNameToControl[i]);
						if (lslider != nullptr) {
							if ((lslider->getComponentID().equalsIgnoreCase(param1name)) || (lslider->getComponentID().equalsIgnoreCase(param2name))) {
								if (lslider->isShowing())
									lslider->repaint();
							}
						}
					}
				}
			}

			if (processor->needsUIPresetUpdate()) {
				VASTPresetComponent* pres = vaporizerComponent->getConcertinaPanel()->getPresetOverlay();
				if (pres != nullptr)
					pres->updateAll();
				processor->clearUIPresetFlag();
			}
			if (processor->needsUIPresetReloadUpdate()) {
				VASTPresetComponent* pres = vaporizerComponent->getConcertinaPanel()->getPresetOverlay();
				if (pres != nullptr)
					pres->reloadPresets();
				processor->clearUIPresetReloadFlag();
			}

			processor->clearUIUpdateFlag();
		}

		if (processor->wantsUIAlert()) {
			processor->clearUIAlertFlag();
			AlertWindow::showMessageBoxAsync(MessageBoxIconType::WarningIcon, TRANS("Load preset failed"), TRANS("Invalid data structure."), TRANS("Continue"), this);
		}

		VASTMasterVoicingComponent* voicingComp = vaporizerComponent->getMasterVoicingComponent();
		if (voicingComp != nullptr) {
			Label* labelV = voicingComp->getComponentCVoices();
			int numVoicesPlaying = processor->m_pVASTXperience.m_Poly.numNotesPlaying();
			int numOscsPlaying = processor->m_pVASTXperience.m_Poly.numOscsPlaying();
			labelV->setText(String(String(numVoicesPlaying) + "/" + String(numOscsPlaying)), NotificationType::dontSendNotification);
		}
	}
}

VASTAudioProcessor* VASTAudioProcessorEditor::getProcessor() {
	return processor;
}

void VASTAudioProcessorEditor::paint(Graphics& ) {
	//do nothing, but needed for opaque
}

//==============================================================================


void VASTAudioProcessorEditor::resized() {
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
	VDBG("AudioProcessorEditor resized to w: " + String(this->getWidth()) + " h: " + String(this->getHeight()));
	getCurrentVASTLookAndFeel()->setCurrentScalingFactors(getProcessor()->getPluginScaleWidthFactor(), getProcessor()->getPluginScaleHeightFactor());
	initAllLookAndFeels();

#if !defined JUCE_LINUX
	if (m_componentBoundsConstrainer.isBeingCornerResized) {
		getProcessor()->m_iUserTargetPluginWidth = getWidth();
		getProcessor()->m_iUserTargetPluginHeight = getHeight();
		getProcessor()->writeSettingsToFile(); //must not be async
	}
#endif
    if (vaporizerComponent.get() != nullptr) {
        if (!resizeCalledFromConstructor)
            vaporizerComponent->setSize(this->getWidth(), this->getHeight());
    }
}

void VASTAudioProcessorEditor::startPaintingToImage() {
    if (vaporizerComponent.get() != nullptr)
        vaporizerComponent->startPaintingToImage();
}
void VASTAudioProcessorEditor::endPaintingToImage() {
    if (vaporizerComponent.get() != nullptr)
        vaporizerComponent->endPaintingToImage();
}

void VASTAudioProcessorEditor::initAllLookAndFeels() {
	int num = getProcessor()->vastLookAndFeels.size() - 1;
	for (int i = 0; i < num; i++) {
		getProcessor()->vastLookAndFeels[i]->initAll();
	}
}

void VASTAudioProcessorEditor::setActiveLookAndFeel(int no) {
	vassert((no >= 0) && (no < getProcessor()->vastLookAndFeels.size()));
	initAllLookAndFeels();
	no = jlimit<int>(0, getProcessor()->vastLookAndFeels.size() -1, no);
	getProcessor()->m_activeLookAndFeel = no;
	setLookAndFeel(getProcessor()->getCurrentVASTLookAndFeel());
	tooltipWindow.setLookAndFeel(getProcessor()->getCurrentVASTLookAndFeel());
	if (vaporizerComponent != nullptr)
		vaporizerComponent->setLookAndFeel(getProcessor()->getCurrentVASTLookAndFeel());
	//LookAndFeel::setDefaultLookAndFeel(getProcessor()->getCurrentVASTLookAndFeel()); //causes problems with standalone app
}

VASTLookAndFeel* VASTAudioProcessorEditor::getCurrentVASTLookAndFeel() {
	return getProcessor()->getCurrentVASTLookAndFeel();
}

void VASTAudioProcessorEditor::showNewerVersionPopup() {
    if (vaporizerComponent.get() == nullptr)
        return;
	getProcessor()->m_showNewerVersionPopup = false;
	//transportable alertwindows without modalloop! https://forum.juce.com/t/is-there-a-easy-way-to-replace-alertwindow-runmodalloop/15072/16
	m_alertWindow = std::make_unique<juce::AlertWindow>(TRANS("Newer version " + getProcessor()->m_newerVersionThatIsAvailble +" available"), TRANS("Please visit the website and download the newest version of Vaporizer2."), juce::AlertWindow::InfoIcon, this);
	m_alertWindow->setLookAndFeel(getProcessor()->getCurrentVASTLookAndFeel());
	m_alertWindow->addButton("Continue", 0, juce::KeyPress(), juce::KeyPress());
	m_alertWindow->addButton("Open Website", 1, juce::KeyPress(), juce::KeyPress());
	m_alertWindow->addTextBlock(L"Please download here: https://www.vast-dynamics.com/?q=products.");
	m_alertWindow->grabKeyboardFocus();
	vaporizerComponent->addChildComponent(m_alertWindow.get());
	m_alertWindow->setCentreRelative(0.5f, 0.5f);
	m_alertWindow->enterModalState(true, ModalCallbackFunction::create([this](int returnValue) {
		if (returnValue == 1) {
			const URL websiteurl = URL("https://www.vast-dynamics.com/?q=products");
			bool worked = websiteurl.launchInDefaultBrowser();
#ifdef _DEBUG
			if (!worked)
				VDBG("Launch browser did not work.");
#endif
            worked = true;
		}
		m_alertWindow->setLookAndFeel(nullptr);
		m_alertWindow = nullptr;
	}), true);
}
